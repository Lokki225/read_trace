{
  "version": 3,
  "sources": ["../src/extension/logger.ts", "../src/extension/api.ts", "../src/extension/queue/syncQueue.ts", "../src/extension/queue/deduplicator.ts", "../src/extension/background.ts"],
  "sourcesContent": ["export type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\nexport interface LogEntry {\n  timestamp: number;\n  level: LogLevel;\n  event: string;\n  details?: unknown;\n}\n\nconst MAX_LOG_ENTRIES = 200;\n\nlet debugMode = false;\nconst logHistory: LogEntry[] = [];\n\nexport function setDebugMode(enabled: boolean): void {\n  debugMode = enabled;\n}\n\nexport function isDebugMode(): boolean {\n  return debugMode;\n}\n\nfunction addEntry(level: LogLevel, event: string, details?: unknown): void {\n  const entry: LogEntry = {\n    timestamp: Date.now(),\n    level,\n    event,\n    details,\n  };\n\n  logHistory.push(entry);\n\n  if (logHistory.length > MAX_LOG_ENTRIES) {\n    logHistory.splice(0, logHistory.length - MAX_LOG_ENTRIES);\n  }\n}\n\nexport function log(event: string, details?: unknown): void {\n  addEntry('info', event, details);\n  if (debugMode) {\n    console.log(`[ReadTrace] ${event}`, details ?? '');\n  }\n}\n\nexport function debug(message: string, details?: unknown): void {\n  addEntry('debug', message, details);\n  if (debugMode) {\n    console.debug(`[ReadTrace:debug] ${message}`, details ?? '');\n  }\n}\n\nexport function warn(message: string, details?: unknown): void {\n  addEntry('warn', message, details);\n  console.warn(`[ReadTrace:warn] ${message}`, details ?? '');\n}\n\nexport function error(message: string, err?: unknown): void {\n  const details = err instanceof Error ? { message: err.message, stack: err.stack } : err;\n  addEntry('error', message, details);\n  console.error(`[ReadTrace:error] ${message}`, details ?? '');\n}\n\nexport function getLogs(): LogEntry[] {\n  return [...logHistory];\n}\n\nexport function clearLogs(): void {\n  logHistory.splice(0, logHistory.length);\n}\n", "import { BackgroundProgressUpdate, SyncResponse } from './types';\nimport { log, warn, error as logError } from './logger';\n\nconst SYNC_TIMEOUT_MS = 5000;\nconst API_BASE_URL = typeof process !== 'undefined' && process.env.NEXT_PUBLIC_APP_URL\n  ? process.env.NEXT_PUBLIC_APP_URL\n  : '';\n\nlet authToken: string | null = null;\n\nexport function setAuthToken(token: string | null): void {\n  authToken = token;\n}\n\nexport function getAuthToken(): string | null {\n  return authToken;\n}\n\nfunction buildHeaders(): HeadersInit {\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n  if (authToken) {\n    headers['Authorization'] = `Bearer ${authToken}`;\n  }\n  return headers;\n}\n\nexport async function syncProgress(update: BackgroundProgressUpdate): Promise<SyncResponse> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), SYNC_TIMEOUT_MS);\n\n  const url = `${API_BASE_URL}/api/progress/sync`;\n\n  log('api:sync:start', { series_id: update.series_id, chapter: update.chapter });\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: buildHeaders(),\n      body: JSON.stringify({\n        series_id: update.series_id,\n        chapter: update.chapter,\n        scroll_position: update.scroll_position,\n        timestamp: update.timestamp,\n      }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeoutId);\n\n    if (!response.ok) {\n      const statusCode = response.status;\n      if (statusCode >= 400 && statusCode < 500) {\n        warn('api:sync:client-error', { status: statusCode, series_id: update.series_id });\n        return { success: false, error: `Client error: ${statusCode}` };\n      }\n      warn('api:sync:server-error', { status: statusCode, series_id: update.series_id });\n      return { success: false, error: `Server error: ${statusCode}` };\n    }\n\n    const data = (await response.json()) as SyncResponse;\n    log('api:sync:success', { series_id: update.series_id, synced_at: data.synced_at });\n    return data;\n  } catch (err) {\n    clearTimeout(timeoutId);\n\n    if (err instanceof Error && err.name === 'AbortError') {\n      warn('api:sync:timeout', { series_id: update.series_id });\n      return { success: false, error: 'API sync timeout - queuing for retry' };\n    }\n\n    logError('api:sync:error', err);\n    return { success: false, error: err instanceof Error ? err.message : 'Unknown error' };\n  }\n}\n", "import { BackgroundProgressUpdate, QueuedUpdate } from '../types';\nimport { log, warn, error as logError } from '../logger';\n\nconst QUEUE_STORAGE_KEY = 'readtrace_sync_queue';\nconst MAX_QUEUE_SIZE = 100;\nconst MAX_RETRIES = 5;\n\nlet queue: QueuedUpdate[] = [];\n\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\n}\n\nexport function add(update: BackgroundProgressUpdate): QueuedUpdate {\n  const queued: QueuedUpdate = {\n    ...update,\n    id: generateId(),\n    retries: 0,\n  };\n\n  queue.push(queued);\n  log('queue:add', { id: queued.id, series_id: update.series_id, chapter: update.chapter });\n\n  if (queue.length > MAX_QUEUE_SIZE) {\n    const removed = queue.splice(0, queue.length - MAX_QUEUE_SIZE);\n    warn('queue:overflow', { removed: removed.length, message: 'Storage quota exceeded - removing oldest entries' });\n  }\n\n  save();\n  return queued;\n}\n\nexport function remove(id: string): void {\n  const before = queue.length;\n  queue = queue.filter((item) => item.id !== id);\n  if (queue.length < before) {\n    log('queue:remove', { id });\n    save();\n  }\n}\n\nexport function getAll(): QueuedUpdate[] {\n  return [...queue];\n}\n\nexport function size(): number {\n  return queue.length;\n}\n\nexport function clear(): void {\n  queue = [];\n  try {\n    localStorage.removeItem(QUEUE_STORAGE_KEY);\n  } catch {\n    // localStorage may not be available in all contexts\n  }\n  log('queue:clear');\n}\n\nexport function save(): void {\n  try {\n    localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(queue));\n  } catch (err) {\n    logError('queue:save:error', err);\n  }\n}\n\nexport function load(): void {\n  try {\n    const stored = localStorage.getItem(QUEUE_STORAGE_KEY);\n    if (stored) {\n      const parsed = JSON.parse(stored) as QueuedUpdate[];\n      if (Array.isArray(parsed)) {\n        queue = parsed;\n        log('queue:load', { count: queue.length });\n      }\n    }\n  } catch (err) {\n    logError('queue:load:error', err);\n    queue = [];\n  }\n}\n\nexport function incrementRetry(id: string): void {\n  const item = queue.find((q) => q.id === id);\n  if (item) {\n    item.retries += 1;\n    item.lastRetry = Date.now();\n    save();\n  }\n}\n\nexport function removeExhausted(): void {\n  const before = queue.length;\n  queue = queue.filter((item) => item.retries < MAX_RETRIES);\n  const removed = before - queue.length;\n  if (removed > 0) {\n    warn('queue:exhausted-removed', { removed });\n    save();\n  }\n}\n\nexport function getMaxRetries(): number {\n  return MAX_RETRIES;\n}\n\nconst BASE_BACKOFF_MS = 1000;\nconst MAX_BACKOFF_MS = 30000;\n\nexport function getBackoffDelay(retries: number): number {\n  const delay = BASE_BACKOFF_MS * Math.pow(2, retries);\n  return Math.min(delay, MAX_BACKOFF_MS);\n}\n\nexport function isReadyForRetry(item: QueuedUpdate): boolean {\n  if (item.retries === 0) return true;\n  if (!item.lastRetry) return true;\n  const delay = getBackoffDelay(item.retries);\n  return Date.now() - item.lastRetry >= delay;\n}\n\nexport function getRetryReady(): QueuedUpdate[] {\n  return queue.filter(isReadyForRetry);\n}\n\nexport function addFromOffline(update: BackgroundProgressUpdate): QueuedUpdate {\n  const existing = queue.find(\n    (q) => q.series_id === update.series_id && q.chapter === update.chapter\n  );\n  if (existing) {\n    if (update.timestamp > existing.timestamp) {\n      existing.scroll_position = update.scroll_position;\n      existing.timestamp = update.timestamp;\n      existing.url = update.url;\n      save();\n      log('queue:offline-update-merged', { id: existing.id, series_id: update.series_id });\n    }\n    return existing;\n  }\n  return add(update);\n}\n", "import { BackgroundProgressUpdate } from '../types';\nimport { log } from '../logger';\n\nconst DEDUP_WINDOW_MS = 5 * 60 * 1000;\n\ntype DeduplicationKey = string;\n\nfunction makeKey(seriesId: string, chapter: number): DeduplicationKey {\n  return `${seriesId}::${chapter}`;\n}\n\nconst store = new Map<DeduplicationKey, BackgroundProgressUpdate>();\n\nexport function add(update: BackgroundProgressUpdate): void {\n  const key = makeKey(update.series_id, update.chapter);\n  const existing = store.get(key);\n\n  if (!existing || update.timestamp >= existing.timestamp) {\n    store.set(key, { ...update });\n    log('dedup:add', { key, timestamp: update.timestamp });\n  }\n}\n\nexport function isDuplicate(update: BackgroundProgressUpdate): boolean {\n  const key = makeKey(update.series_id, update.chapter);\n  const existing = store.get(key);\n\n  if (!existing) {\n    return false;\n  }\n\n  const isDup = update.timestamp <= existing.timestamp;\n  if (isDup) {\n    log('dedup:duplicate-detected', { key, incoming: update.timestamp, existing: existing.timestamp });\n  }\n  return isDup;\n}\n\nexport function getLatest(seriesId: string, chapter: number): BackgroundProgressUpdate | null {\n  const key = makeKey(seriesId, chapter);\n  return store.get(key) ?? null;\n}\n\nexport function deduplicate(updates: BackgroundProgressUpdate[]): BackgroundProgressUpdate[] {\n  const latestMap = new Map<DeduplicationKey, BackgroundProgressUpdate>();\n\n  for (const update of updates) {\n    const key = makeKey(update.series_id, update.chapter);\n    const existing = latestMap.get(key);\n    if (!existing || update.timestamp > existing.timestamp) {\n      latestMap.set(key, update);\n    }\n  }\n\n  return Array.from(latestMap.values());\n}\n\nexport function purgeExpired(): void {\n  const cutoff = Date.now() - DEDUP_WINDOW_MS;\n  let purged = 0;\n\n  for (const [key, update] of store.entries()) {\n    if (update.timestamp < cutoff) {\n      store.delete(key);\n      purged++;\n    }\n  }\n\n  if (purged > 0) {\n    log('dedup:purge', { purged });\n  }\n}\n\nexport function clear(): void {\n  store.clear();\n  log('dedup:clear');\n}\n\nexport function size(): number {\n  return store.size;\n}\n", "import { BackgroundProgressUpdate, BackgroundMessage, BackgroundMessageResponse } from './types';\nimport { syncProgress } from './api';\nimport * as queue from './queue/syncQueue';\nimport * as dedup from './queue/deduplicator';\nimport { log, warn, error as logError, debug } from './logger';\n\nlet isOnline = true;\nlet isInitialized = false;\n\nexport function getIsOnline(): boolean {\n  return isOnline;\n}\n\nexport function getIsInitialized(): boolean {\n  return isInitialized;\n}\n\nfunction validateUpdate(update: unknown): update is BackgroundProgressUpdate {\n  if (!update || typeof update !== 'object') return false;\n  const u = update as Record<string, unknown>;\n  return (\n    typeof u.series_id === 'string' &&\n    u.series_id.length > 0 &&\n    typeof u.chapter === 'number' &&\n    u.chapter > 0 &&\n    typeof u.scroll_position === 'number' &&\n    u.scroll_position >= 0 &&\n    u.scroll_position <= 100 &&\n    typeof u.timestamp === 'number' &&\n    u.timestamp > 0 &&\n    typeof u.url === 'string'\n  );\n}\n\nexport async function handleProgressUpdate(\n  update: BackgroundProgressUpdate\n): Promise<BackgroundMessageResponse> {\n  debug('background:handle-update', { series_id: update.series_id, chapter: update.chapter });\n\n  if (dedup.isDuplicate(update)) {\n    log('background:duplicate-skipped', { series_id: update.series_id, chapter: update.chapter });\n    return { success: true, queued: false };\n  }\n\n  dedup.add(update);\n\n  if (!isOnline) {\n    queue.add(update);\n    log('background:queued-offline', { series_id: update.series_id });\n    return { success: true, queued: true };\n  }\n\n  const result = await syncProgress(update);\n\n  if (!result.success) {\n    queue.add(update);\n    log('background:queued-after-failure', { series_id: update.series_id, error: result.error });\n    return { success: false, queued: true, error: result.error };\n  }\n\n  return { success: true, queued: false };\n}\n\nexport async function processQueue(): Promise<void> {\n  const pending = queue.getAll();\n\n  if (pending.length === 0) {\n    debug('background:queue-empty');\n  } else {\n    log('background:processing-queue', { count: pending.length });\n\n    for (const item of pending) {\n      const result = await syncProgress(item);\n\n      if (result.success) {\n        queue.remove(item.id);\n        log('background:queue-item-synced', { id: item.id, series_id: item.series_id });\n      } else {\n        queue.incrementRetry(item.id);\n        warn('background:queue-item-failed', { id: item.id, retries: item.retries + 1, error: result.error });\n      }\n    }\n  }\n\n  queue.removeExhausted();\n}\n\nexport function onOnline(): void {\n  isOnline = true;\n  log('background:online');\n  processQueue().catch((err) => logError('background:process-queue-error', err));\n}\n\nexport function onOffline(): void {\n  isOnline = false;\n  log('background:offline');\n}\n\nexport function getQueuedUpdates(): ReturnType<typeof queue.getAll> {\n  return queue.getAll();\n}\n\nfunction handleMessage(\n  message: unknown,\n  _sender: unknown,\n  sendResponse: (response: BackgroundMessageResponse) => void\n): boolean {\n  const msg = message as BackgroundMessage;\n\n  if (!msg || msg.type !== 'PROGRESS_UPDATE') {\n    sendResponse({ success: false, queued: false, error: 'Unknown message type' });\n    return false;\n  }\n\n  if (!validateUpdate(msg.payload)) {\n    warn('background:invalid-payload', { payload: msg.payload });\n    sendResponse({ success: false, queued: false, error: 'Invalid progress data' });\n    return false;\n  }\n\n  handleProgressUpdate(msg.payload)\n    .then(sendResponse)\n    .catch((err) => {\n      logError('background:message-handler-error', err);\n      sendResponse({ success: false, queued: false, error: 'Internal error' });\n    });\n\n  return true;\n}\n\nexport function initialize(): void {\n  if (isInitialized) return;\n\n  queue.load();\n\n  isOnline =\n    typeof navigator !== 'undefined' && typeof navigator.onLine === 'boolean'\n      ? navigator.onLine\n      : true;\n\n  if (typeof self !== 'undefined' && typeof (self as Window & typeof globalThis).addEventListener === 'function') {\n    (self as Window & typeof globalThis).addEventListener('online', onOnline);\n    (self as Window & typeof globalThis).addEventListener('offline', onOffline);\n  }\n\n  if (\n    typeof chrome !== 'undefined' &&\n    chrome.runtime &&\n    chrome.runtime.onMessage\n  ) {\n    chrome.runtime.onMessage.addListener(handleMessage);\n  }\n\n  isInitialized = true;\n  log('background:initialized', { isOnline });\n}\n"],
  "mappings": "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",
  "names": ["add", "add"]
}
